"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/supabase.js":
/*!*************************!*\
  !*** ./lib/supabase.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authOperations: () => (/* binding */ authOperations),\n/* harmony export */   createTables: () => (/* binding */ createTables),\n/* harmony export */   dataSourceOperations: () => (/* binding */ dataSourceOperations),\n/* harmony export */   removalOperations: () => (/* binding */ removalOperations),\n/* harmony export */   searchOperations: () => (/* binding */ searchOperations),\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Environment variables for Supabase configuration\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nif (!supabaseUrl || !supabaseAnonKey) {\n    console.error('Missing Supabase environment variables. Please check your .env.local file.');\n}\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Database schema for our application\nconst createTables = async ()=>{\n    // This would be run once to set up the database schema\n    // In a real application, this would be done via Supabase dashboard or migrations\n    const searchHistoryTable = \"\\n    CREATE TABLE IF NOT EXISTS search_history (\\n      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n      full_name TEXT NOT NULL,\\n      phone TEXT,\\n      email TEXT,\\n      results JSONB,\\n      user_id UUID REFERENCES auth.users(id)\\n    );\\n  \";\n    const dataSourcesTable = \"\\n    CREATE TABLE IF NOT EXISTS data_sources (\\n      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n      name TEXT NOT NULL UNIQUE,\\n      url TEXT NOT NULL,\\n      api_endpoint TEXT,\\n      risk_level TEXT CHECK (risk_level IN ('low', 'medium', 'high')),\\n      description TEXT,\\n      data_types TEXT[],\\n      is_active BOOLEAN DEFAULT true\\n    );\\n  \";\n    const removalRequestsTable = \"\\n    CREATE TABLE IF NOT EXISTS removal_requests (\\n      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\\n      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\\n      user_id UUID REFERENCES auth.users(id),\\n      data_source_id UUID REFERENCES data_sources(id),\\n      full_name TEXT NOT NULL,\\n      phone TEXT,\\n      email TEXT,\\n      status TEXT CHECK (status IN ('pending', 'submitted', 'completed', 'failed')) DEFAULT 'pending',\\n      notes TEXT\\n    );\\n  \";\n    console.log('Database schema defined. In production, these would be created via Supabase dashboard.');\n    return {\n        searchHistoryTable,\n        dataSourcesTable,\n        removalRequestsTable\n    };\n};\n// Helper functions for database operations\nconst searchOperations = {\n    // Save search results to database\n    saveSearch: async (searchData)=>{\n        try {\n            const { data, error } = await supabase.from('search_history').insert([\n                searchData\n            ]).select();\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error saving search:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Get user's search history\n    getSearchHistory: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('search_history').select('*').eq('user_id', userId).order('created_at', {\n                ascending: false\n            });\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error fetching search history:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    }\n};\nconst dataSourceOperations = {\n    // Get all active data sources\n    getDataSources: async ()=>{\n        try {\n            const { data, error } = await supabase.from('data_sources').select('*').eq('is_active', true).order('name');\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error fetching data sources:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Add a new data source\n    addDataSource: async (sourceData)=>{\n        try {\n            const { data, error } = await supabase.from('data_sources').insert([\n                sourceData\n            ]).select();\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error adding data source:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    }\n};\nconst removalOperations = {\n    // Submit a removal request\n    submitRemovalRequest: async (requestData)=>{\n        try {\n            const { data, error } = await supabase.from('removal_requests').insert([\n                requestData\n            ]).select();\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error submitting removal request:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Get user's removal requests\n    getRemovalRequests: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('removal_requests').select(\"\\n          *,\\n          data_sources (\\n            name,\\n            url\\n          )\\n        \").eq('user_id', userId).order('created_at', {\n                ascending: false\n            });\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error fetching removal requests:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Update removal request status\n    updateRemovalStatus: async function(requestId, status) {\n        let notes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        try {\n            const updateData = {\n                status,\n                updated_at: new Date().toISOString()\n            };\n            if (notes) updateData.notes = notes;\n            const { data, error } = await supabase.from('removal_requests').update(updateData).eq('id', requestId).select();\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            console.error('Error updating removal request:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    }\n};\n// Authentication helpers\nconst authOperations = {\n    // Sign up a new user\n    signUp: async (email, password)=>{\n        try {\n            const { data, error } = await supabase.auth.signUp({\n                email,\n                password\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            console.error('Error signing up:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Sign in user\n    signIn: async (email, password)=>{\n        try {\n            const { data, error } = await supabase.auth.signInWithPassword({\n                email,\n                password\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            console.error('Error signing in:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Sign out user\n    signOut: async ()=>{\n        try {\n            const { error } = await supabase.auth.signOut();\n            return {\n                error\n            };\n        } catch (error) {\n            console.error('Error signing out:', error);\n            return {\n                error\n            };\n        }\n    },\n    // Get current user\n    getCurrentUser: async ()=>{\n        try {\n            const { data: { user }, error } = await supabase.auth.getUser();\n            return {\n                user,\n                error\n            };\n        } catch (error) {\n            console.error('Error getting user:', error);\n            return {\n                user: null,\n                error\n            };\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzdDLE9BQU87Z0JBQUUzQztZQUFNO1FBQ2pCLEVBQUUsT0FBT0EsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQyxPQUFPO2dCQUFFQTtZQUFNO1FBQ2pCO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkI0QyxnQkFBZ0I7UUFDZCxJQUFJO1lBQ0YsTUFBTSxFQUFFbEMsTUFBTSxFQUFFbUMsSUFBSSxFQUFFLEVBQUU3QyxLQUFLLEVBQUUsR0FBRyxNQUFNQyxTQUFTdUMsSUFBSSxDQUFDTSxPQUFPO1lBQzdELE9BQU87Z0JBQUVEO2dCQUFNN0M7WUFBTTtRQUN2QixFQUFFLE9BQU9BLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHVCQUF1QkE7WUFDckMsT0FBTztnQkFBRTZDLE1BQU07Z0JBQU03QztZQUFNO1FBQzdCO0lBQ0Y7QUFDRixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvc3dhbmFnYW4vcHJvamVjdHMvYXBwLXplcm8tdHJhY2UtbGFicy9saWIvc3VwYWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIFN1cGFiYXNlIGNvbmZpZ3VyYXRpb25cbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxuXG5pZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUFub25LZXkpIHtcbiAgY29uc29sZS5lcnJvcignTWlzc2luZyBTdXBhYmFzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuIFBsZWFzZSBjaGVjayB5b3VyIC5lbnYubG9jYWwgZmlsZS4nKVxufVxuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGF0YWJhc2Ugc2NoZW1hIGZvciBvdXIgYXBwbGljYXRpb25cbmV4cG9ydCBjb25zdCBjcmVhdGVUYWJsZXMgPSBhc3luYyAoKSA9PiB7XG4gIC8vIFRoaXMgd291bGQgYmUgcnVuIG9uY2UgdG8gc2V0IHVwIHRoZSBkYXRhYmFzZSBzY2hlbWFcbiAgLy8gSW4gYSByZWFsIGFwcGxpY2F0aW9uLCB0aGlzIHdvdWxkIGJlIGRvbmUgdmlhIFN1cGFiYXNlIGRhc2hib2FyZCBvciBtaWdyYXRpb25zXG4gIFxuICBjb25zdCBzZWFyY2hIaXN0b3J5VGFibGUgPSBgXG4gICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgc2VhcmNoX2hpc3RvcnkgKFxuICAgICAgaWQgVVVJRCBERUZBVUxUIGdlbl9yYW5kb21fdXVpZCgpIFBSSU1BUlkgS0VZLFxuICAgICAgY3JlYXRlZF9hdCBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUgREVGQVVMVCBOT1coKSxcbiAgICAgIGZ1bGxfbmFtZSBURVhUIE5PVCBOVUxMLFxuICAgICAgcGhvbmUgVEVYVCxcbiAgICAgIGVtYWlsIFRFWFQsXG4gICAgICByZXN1bHRzIEpTT05CLFxuICAgICAgdXNlcl9pZCBVVUlEIFJFRkVSRU5DRVMgYXV0aC51c2VycyhpZClcbiAgICApO1xuICBgXG4gIFxuICBjb25zdCBkYXRhU291cmNlc1RhYmxlID0gYFxuICAgIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGRhdGFfc291cmNlcyAoXG4gICAgICBpZCBVVUlEIERFRkFVTFQgZ2VuX3JhbmRvbV91dWlkKCkgUFJJTUFSWSBLRVksXG4gICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxuICAgICAgbmFtZSBURVhUIE5PVCBOVUxMIFVOSVFVRSxcbiAgICAgIHVybCBURVhUIE5PVCBOVUxMLFxuICAgICAgYXBpX2VuZHBvaW50IFRFWFQsXG4gICAgICByaXNrX2xldmVsIFRFWFQgQ0hFQ0sgKHJpc2tfbGV2ZWwgSU4gKCdsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnKSksXG4gICAgICBkZXNjcmlwdGlvbiBURVhULFxuICAgICAgZGF0YV90eXBlcyBURVhUW10sXG4gICAgICBpc19hY3RpdmUgQk9PTEVBTiBERUZBVUxUIHRydWVcbiAgICApO1xuICBgXG4gIFxuICBjb25zdCByZW1vdmFsUmVxdWVzdHNUYWJsZSA9IGBcbiAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyByZW1vdmFsX3JlcXVlc3RzIChcbiAgICAgIGlkIFVVSUQgREVGQVVMVCBnZW5fcmFuZG9tX3V1aWQoKSBQUklNQVJZIEtFWSxcbiAgICAgIGNyZWF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKCksXG4gICAgICB1cGRhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxuICAgICAgdXNlcl9pZCBVVUlEIFJFRkVSRU5DRVMgYXV0aC51c2VycyhpZCksXG4gICAgICBkYXRhX3NvdXJjZV9pZCBVVUlEIFJFRkVSRU5DRVMgZGF0YV9zb3VyY2VzKGlkKSxcbiAgICAgIGZ1bGxfbmFtZSBURVhUIE5PVCBOVUxMLFxuICAgICAgcGhvbmUgVEVYVCxcbiAgICAgIGVtYWlsIFRFWFQsXG4gICAgICBzdGF0dXMgVEVYVCBDSEVDSyAoc3RhdHVzIElOICgncGVuZGluZycsICdzdWJtaXR0ZWQnLCAnY29tcGxldGVkJywgJ2ZhaWxlZCcpKSBERUZBVUxUICdwZW5kaW5nJyxcbiAgICAgIG5vdGVzIFRFWFRcbiAgICApO1xuICBgXG4gIFxuICBjb25zb2xlLmxvZygnRGF0YWJhc2Ugc2NoZW1hIGRlZmluZWQuIEluIHByb2R1Y3Rpb24sIHRoZXNlIHdvdWxkIGJlIGNyZWF0ZWQgdmlhIFN1cGFiYXNlIGRhc2hib2FyZC4nKVxuICByZXR1cm4geyBzZWFyY2hIaXN0b3J5VGFibGUsIGRhdGFTb3VyY2VzVGFibGUsIHJlbW92YWxSZXF1ZXN0c1RhYmxlIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgZGF0YWJhc2Ugb3BlcmF0aW9uc1xuZXhwb3J0IGNvbnN0IHNlYXJjaE9wZXJhdGlvbnMgPSB7XG4gIC8vIFNhdmUgc2VhcmNoIHJlc3VsdHMgdG8gZGF0YWJhc2VcbiAgc2F2ZVNlYXJjaDogYXN5bmMgKHNlYXJjaERhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NlYXJjaF9oaXN0b3J5JylcbiAgICAgICAgLmluc2VydChbc2VhcmNoRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZWFyY2g6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgfVxuICB9LFxuICBcbiAgLy8gR2V0IHVzZXIncyBzZWFyY2ggaGlzdG9yeVxuICBnZXRTZWFyY2hIaXN0b3J5OiBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzZWFyY2hfaGlzdG9yeScpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNlYXJjaCBoaXN0b3J5OicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGF0YVNvdXJjZU9wZXJhdGlvbnMgPSB7XG4gIC8vIEdldCBhbGwgYWN0aXZlIGRhdGEgc291cmNlc1xuICBnZXREYXRhU291cmNlczogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZGF0YV9zb3VyY2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgICAgLm9yZGVyKCduYW1lJylcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhIHNvdXJjZXM6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgfVxuICB9LFxuICBcbiAgLy8gQWRkIGEgbmV3IGRhdGEgc291cmNlXG4gIGFkZERhdGFTb3VyY2U6IGFzeW5jIChzb3VyY2VEYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdkYXRhX3NvdXJjZXMnKVxuICAgICAgICAuaW5zZXJ0KFtzb3VyY2VEYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGRhdGEgc291cmNlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZhbE9wZXJhdGlvbnMgPSB7XG4gIC8vIFN1Ym1pdCBhIHJlbW92YWwgcmVxdWVzdFxuICBzdWJtaXRSZW1vdmFsUmVxdWVzdDogYXN5bmMgKHJlcXVlc3REYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyZW1vdmFsX3JlcXVlc3RzJylcbiAgICAgICAgLmluc2VydChbcmVxdWVzdERhdGFdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJtaXR0aW5nIHJlbW92YWwgcmVxdWVzdDonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICB9XG4gIH0sXG4gIFxuICAvLyBHZXQgdXNlcidzIHJlbW92YWwgcmVxdWVzdHNcbiAgZ2V0UmVtb3ZhbFJlcXVlc3RzOiBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyZW1vdmFsX3JlcXVlc3RzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgKixcbiAgICAgICAgICBkYXRhX3NvdXJjZXMgKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHVybFxuICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZW1vdmFsIHJlcXVlc3RzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfSxcbiAgXG4gIC8vIFVwZGF0ZSByZW1vdmFsIHJlcXVlc3Qgc3RhdHVzXG4gIHVwZGF0ZVJlbW92YWxTdGF0dXM6IGFzeW5jIChyZXF1ZXN0SWQsIHN0YXR1cywgbm90ZXMgPSBudWxsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IFxuICAgICAgICBzdGF0dXMsIFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgXG4gICAgICB9XG4gICAgICBpZiAobm90ZXMpIHVwZGF0ZURhdGEubm90ZXMgPSBub3Rlc1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncmVtb3ZhbF9yZXF1ZXN0cycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJlcXVlc3RJZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcmVtb3ZhbCByZXF1ZXN0OicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdXRoZW50aWNhdGlvbiBoZWxwZXJzXG5leHBvcnQgY29uc3QgYXV0aE9wZXJhdGlvbnMgPSB7XG4gIC8vIFNpZ24gdXAgYSBuZXcgdXNlclxuICBzaWduVXA6IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduVXAoe1xuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzaWduaW5nIHVwOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfSxcbiAgXG4gIC8vIFNpZ24gaW4gdXNlclxuICBzaWduSW46IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzaWduaW5nIGluOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfSxcbiAgXG4gIC8vIFNpZ24gb3V0IHVzZXJcbiAgc2lnbk91dDogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKVxuICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzaWduaW5nIG91dDonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICB9XG4gIH0sXG4gIFxuICAvLyBHZXQgY3VycmVudCB1c2VyXG4gIGdldEN1cnJlbnRVc2VyOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgcmV0dXJuIHsgdXNlciwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXI6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyB1c2VyOiBudWxsLCBlcnJvciB9XG4gICAgfVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImNvbnNvbGUiLCJlcnJvciIsInN1cGFiYXNlIiwiY3JlYXRlVGFibGVzIiwic2VhcmNoSGlzdG9yeVRhYmxlIiwiZGF0YVNvdXJjZXNUYWJsZSIsInJlbW92YWxSZXF1ZXN0c1RhYmxlIiwibG9nIiwic2VhcmNoT3BlcmF0aW9ucyIsInNhdmVTZWFyY2giLCJzZWFyY2hEYXRhIiwiZGF0YSIsImZyb20iLCJpbnNlcnQiLCJzZWxlY3QiLCJnZXRTZWFyY2hIaXN0b3J5IiwidXNlcklkIiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsImRhdGFTb3VyY2VPcGVyYXRpb25zIiwiZ2V0RGF0YVNvdXJjZXMiLCJhZGREYXRhU291cmNlIiwic291cmNlRGF0YSIsInJlbW92YWxPcGVyYXRpb25zIiwic3VibWl0UmVtb3ZhbFJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsImdldFJlbW92YWxSZXF1ZXN0cyIsInVwZGF0ZVJlbW92YWxTdGF0dXMiLCJyZXF1ZXN0SWQiLCJzdGF0dXMiLCJub3RlcyIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlIiwiYXV0aE9wZXJhdGlvbnMiLCJzaWduVXAiLCJlbWFpbCIsInBhc3N3b3JkIiwiYXV0aCIsInNpZ25JbiIsInNpZ25JbldpdGhQYXNzd29yZCIsInNpZ25PdXQiLCJnZXRDdXJyZW50VXNlciIsInVzZXIiLCJnZXRVc2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.js\n"));

/***/ })

});